int main(int argc, char **argv)
{
  Sciara *sciara;
  init(sciara);

  // Input data
  int max_steps = atoi(argv[MAX_STEPS_ID]);
  loadConfiguration(argv[INPUT_PATH_ID], sciara);

  // Domain boundaries and neighborhood
  int i_start = 0, i_end = sciara->domain->rows; // [i_start,i_end[: kernels application range along the rows
  int j_start = 0, j_end = sciara->domain->cols; // [j_start,j_end[: kernels application range along the cols

  // simulation initialization and loop
  double total_current_lava = -1;
  simulationInitialize(sciara);

  util::Timer cl_timer;

  int reduceInterval = atoi(argv[REDUCE_INTERVL_ID]);
  double thickness_threshold = atof(argv[THICKNESS_THRESHOLD_ID]);
  while ((max_steps > 0 && sciara->simulation->step < max_steps) || (sciara->simulation->elapsed_time <= sciara->simulation->effusion_duration) || (total_current_lava == -1 || total_current_lava > thickness_threshold))
  {
    sciara->simulation->elapsed_time += sciara->parameters->Pclock;
    sciara->simulation->step++;

    // Apply the emitLava kernel to the whole domain and update the Sh and ST state variables
#pragma omp parallel for
    for (int i = i_start; i < i_end; i++)
      for (int j = j_start; j < j_end; j++)
        emitLava(i, j,
                 sciara->domain->rows,
                 sciara->domain->cols,
                 sciara->simulation->vent,
                 sciara->simulation->elapsed_time,
                 sciara->parameters->Pclock,
                 sciara->simulation->emission_time,
                 sciara->simulation->total_emitted_lava,
                 sciara->parameters->Pac,
                 sciara->parameters->PTvent,
                 sciara->substates->Sh,
                 sciara->substates->Sh_next,
                 sciara->substates->ST_next);
    memcpy(sciara->substates->Sh, sciara->substates->Sh_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);
    memcpy(sciara->substates->ST, sciara->substates->ST_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);

    // Apply the computeOutflows kernel to the whole domain
#pragma omp parallel for
    for (int i = i_start; i < i_end; i++)
      for (int j = j_start; j < j_end; j++)
        computeOutflows(i, j,
                        sciara->domain->rows,
                        sciara->domain->cols,
                        sciara->X->Xi,
                        sciara->X->Xj,
                        sciara->substates->Sz,
                        sciara->substates->Sh,
                        sciara->substates->ST,
                        sciara->substates->Mf,
                        sciara->parameters->Pc,
                        sciara->parameters->a,
                        sciara->parameters->b,
                        sciara->parameters->c,
                        sciara->parameters->d);

    // Apply the massBalance mass balance kernel to the whole domain and update the Sh and ST state variables
#pragma omp parallel for
    for (int i = i_start; i < i_end; i++)
      for (int j = j_start; j < j_end; j++)
        massBalance(i, j,
                    sciara->domain->rows,
                    sciara->domain->cols,
                    sciara->X->Xi,
                    sciara->X->Xj,
                    sciara->substates->Sh,
                    sciara->substates->Sh_next,
                    sciara->substates->ST,
                    sciara->substates->ST_next,
                    sciara->substates->Mf);
    memcpy(sciara->substates->Sh, sciara->substates->Sh_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);
    memcpy(sciara->substates->ST, sciara->substates->ST_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);

    // Apply the computeNewTemperatureAndSolidification kernel to the whole domain
#pragma omp parallel for
    for (int i = i_start; i < i_end; i++)
      for (int j = j_start; j < j_end; j++)
        computeNewTemperatureAndSolidification(i, j,
                                               sciara->domain->rows,
                                               sciara->domain->cols,
                                               sciara->parameters->Pepsilon,
                                               sciara->parameters->Psigma,
                                               sciara->parameters->Pclock,
                                               sciara->parameters->Pcool,
                                               sciara->parameters->Prho,
                                               sciara->parameters->Pcv,
                                               sciara->parameters->Pac,
                                               sciara->parameters->PTsol,
                                               sciara->substates->Sz,
                                               sciara->substates->Sz_next,
                                               sciara->substates->Sh,
                                               sciara->substates->Sh_next,
                                               sciara->substates->ST,
                                               sciara->substates->ST_next,
                                               sciara->substates->Mf,
                                               sciara->substates->Mhs,
                                               sciara->substates->Mb);
    memcpy(sciara->substates->Sz, sciara->substates->Sz_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);
    memcpy(sciara->substates->Sh, sciara->substates->Sh_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);
    memcpy(sciara->substates->ST, sciara->substates->ST_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);

    // Apply the boundaryConditions kernel to the whole domain and update the Sh and ST state variables
#pragma omp parallel for
    for (int i = i_start; i < i_end; i++)
      for (int j = j_start; j < j_end; j++)
        boundaryConditions(i, j,
                           sciara->domain->rows,
                           sciara->domain->cols,
                           sciara->substates->Mf,
                           sciara->substates->Mb,
                           sciara->substates->Sh,
                           sciara->substates->Sh_next,
                           sciara->substates->ST,
                           sciara->substates->ST_next);
    memcpy(sciara->substates->Sh, sciara->substates->Sh_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);
    memcpy(sciara->substates->ST, sciara->substates->ST_next, sizeof(double) * sciara->domain->rows * sciara->domain->cols);

    // Global reduction
    if (sciara->simulation->step % reduceInterval == 0)
      total_current_lava = reduceAdd(sciara->domain->rows, sciara->domain->cols, sciara->substates->Sh);
  }

  double cl_time = static_cast<double>(cl_timer.getTimeMilliseconds()) / 1000.0;
  printf("Step %d\n", sciara->simulation->step);
  printf("Elapsed time [s]: %lf\n", cl_time);
  printf("Emitted lava [m]: %lf\n", sciara->simulation->total_emitted_lava);
  printf("Current lava [m]: %lf\n", total_current_lava);

  printf("Saving output to %s...\n", argv[OUTPUT_PATH_ID]);
  saveConfiguration(argv[OUTPUT_PATH_ID], sciara);

  printf("Releasing memory...\n");
  finalize(sciara);

  return 0;
}
